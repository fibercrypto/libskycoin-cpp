/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIDefaultApi.h"
#include "OAIHelpers.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace skyqt {

OAIDefaultApi::OAIDefaultApi() {

}

OAIDefaultApi::~OAIDefaultApi() {

}

OAIDefaultApi::OAIDefaultApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
OAIDefaultApi::addressCount() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/addresscount");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::addressCountCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::addressCountCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit addressCountSignal(output);
        emit addressCountSignalFull(worker, output);
    } else {
        emit addressCountSignalE(output, error_type, error_str);
        emit addressCountSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::addressUxouts(const QString& address) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/address_uxouts");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("address"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(address)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::addressUxoutsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::addressUxoutsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<OAIInline_response_200> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        OAIInline_response_200 val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit addressUxoutsSignal(output);
        emit addressUxoutsSignalFull(worker, output);
    } else {
        emit addressUxoutsSignalE(output, error_type, error_str);
        emit addressUxoutsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::balanceGet(const QString& addrs) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/balance");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addrs"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addrs)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::balanceGetCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::balanceGetCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit balanceGetSignal(output);
        emit balanceGetSignalFull(worker, output);
    } else {
        emit balanceGetSignalE(output, error_type, error_str);
        emit balanceGetSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::balancePost(const QString& addrs) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/balance");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addrs"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addrs)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::balancePostCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::balancePostCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit balancePostSignal(output);
        emit balancePostSignalFull(worker, output);
    } else {
        emit balancePostSignalE(output, error_type, error_str);
        emit balancePostSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::block(const QString& hash, const qint32& seq) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/block");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("hash"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(hash)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("seq"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(seq)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::blockCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::blockCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit blockSignal(output);
        emit blockSignalFull(worker, output);
    } else {
        emit blockSignalE(output, error_type, error_str);
        emit blockSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::blockchainMetadata() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/blockchain/metadata");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::blockchainMetadataCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::blockchainMetadataCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit blockchainMetadataSignal(output);
        emit blockchainMetadataSignalFull(worker, output);
    } else {
        emit blockchainMetadataSignalE(output, error_type, error_str);
        emit blockchainMetadataSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::blockchainProgress() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/blockchain/progress");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::blockchainProgressCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::blockchainProgressCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit blockchainProgressSignal(output);
        emit blockchainProgressSignalFull(worker, output);
    } else {
        emit blockchainProgressSignalE(output, error_type, error_str);
        emit blockchainProgressSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::blocksGet(const qint32& start, const qint32& end, const QList<qint32>& seqs) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/blocks");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("start"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(start)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("end"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(end)));
    
    if (seqs.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        foreach(qint32 t, seqs) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("seqs=").append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("seqs=");
        qint32 count = 0;
        foreach(qint32 t, seqs) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("seqs=");
        qint32 count = 0;
        foreach(qint32 t, seqs) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::blocksGetCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::blocksGetCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit blocksGetSignal(output);
        emit blocksGetSignalFull(worker, output);
    } else {
        emit blocksGetSignalE(output, error_type, error_str);
        emit blocksGetSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::blocksPost(const qint32& start, const qint32& end, const QList<qint32>& seqs) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/blocks");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("start"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(start)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("end"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(end)));
    
    if (seqs.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        foreach(qint32 t, seqs) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("seqs=").append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("seqs=");
        qint32 count = 0;
        foreach(qint32 t, seqs) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("seqs=");
        qint32 count = 0;
        foreach(qint32 t, seqs) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::blocksPostCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::blocksPostCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit blocksPostSignal(output);
        emit blocksPostSignalFull(worker, output);
    } else {
        emit blocksPostSignalE(output, error_type, error_str);
        emit blocksPostSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::coinSupply() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/coinSupply");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::coinSupplyCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::coinSupplyCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit coinSupplySignal();
        emit coinSupplySignalFull(worker);
    } else {
        emit coinSupplySignalE(error_type, error_str);
        emit coinSupplySignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::csrf() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/csrf");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::csrfCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::csrfCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIInline_response_200_1 output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit csrfSignal(output);
        emit csrfSignalFull(worker, output);
    } else {
        emit csrfSignalE(output, error_type, error_str);
        emit csrfSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::defaultConnections() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/defaultConnections");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::defaultConnectionsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::defaultConnectionsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        QString val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit defaultConnectionsSignal(output);
        emit defaultConnectionsSignalFull(worker, output);
    } else {
        emit defaultConnectionsSignalE(output, error_type, error_str);
        emit defaultConnectionsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::explorerAddress(const QString& address) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/explorer/address");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("address"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(address)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::explorerAddressCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::explorerAddressCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<OAIInline_response_200_2> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        OAIInline_response_200_2 val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit explorerAddressSignal(output);
        emit explorerAddressSignalFull(worker, output);
    } else {
        emit explorerAddressSignalE(output, error_type, error_str);
        emit explorerAddressSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::health() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/health");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::healthCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::healthCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit healthSignal(output);
        emit healthSignalFull(worker, output);
    } else {
        emit healthSignalE(output, error_type, error_str);
        emit healthSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::lastBlocks(const qint32& num) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/last_blocks");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("num"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(num)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::lastBlocksCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::lastBlocksCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit lastBlocksSignal(output);
        emit lastBlocksSignalFull(worker, output);
    } else {
        emit lastBlocksSignalE(output, error_type, error_str);
        emit lastBlocksSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::networkConnection(const QString& addr) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/connection");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addr"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addr)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::networkConnectionCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::networkConnectionCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIInline_response_200_3 output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit networkConnectionSignal(output);
        emit networkConnectionSignalFull(worker, output);
    } else {
        emit networkConnectionSignalE(output, error_type, error_str);
        emit networkConnectionSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::networkConnections(const QString& states, const QString& direction) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/connections");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("states"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(states)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("direction"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(direction)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::networkConnectionsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::networkConnectionsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<OAIInline_response_200_3> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        OAIInline_response_200_3 val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit networkConnectionsSignal(output);
        emit networkConnectionsSignalFull(worker, output);
    } else {
        emit networkConnectionsSignalE(output, error_type, error_str);
        emit networkConnectionsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::networkConnectionsDisconnect(const QString& id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/connection/disconnect");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::networkConnectionsDisconnectCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::networkConnectionsDisconnectCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit networkConnectionsDisconnectSignal();
        emit networkConnectionsDisconnectSignalFull(worker);
    } else {
        emit networkConnectionsDisconnectSignalE(error_type, error_str);
        emit networkConnectionsDisconnectSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::networkConnectionsExchange() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/connections/exchange");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::networkConnectionsExchangeCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::networkConnectionsExchangeCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        QString val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit networkConnectionsExchangeSignal(output);
        emit networkConnectionsExchangeSignalFull(worker, output);
    } else {
        emit networkConnectionsExchangeSignalE(output, error_type, error_str);
        emit networkConnectionsExchangeSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::networkConnectionsTrust() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/network/connections/trust");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::networkConnectionsTrustCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::networkConnectionsTrustCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<QString> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        QString val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit networkConnectionsTrustSignal(output);
        emit networkConnectionsTrustSignalFull(worker, output);
    } else {
        emit networkConnectionsTrustSignalE(output, error_type, error_str);
        emit networkConnectionsTrustSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::outputsGet(const QList<QString>& address, const QList<QString>& hash) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/outputs");
    
    if (address.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        foreach(QString t, address) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("address=").append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("address=");
        qint32 count = 0;
        foreach(QString t, address) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("address=");
        qint32 count = 0;
        foreach(QString t, address) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
    }
    
    if (hash.size() > 0) {
      if (QString("csv").indexOf("multi") == 0) {
        foreach(QString t, hash) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("hash=").append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("hash=");
        qint32 count = 0;
        foreach(QString t, hash) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
      else if (QString("csv").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("hash=");
        qint32 count = 0;
        foreach(QString t, hash) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(::skyqt::toStringValue(t));
        }
      }
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::outputsGetCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::outputsGetCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit outputsGetSignal(output);
        emit outputsGetSignalFull(worker, output);
    } else {
        emit outputsGetSignalE(output, error_type, error_str);
        emit outputsGetSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::outputsPost(const QString& address, const QString& hash) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/outputs");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("address"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(address)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("hash"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(hash)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::outputsPostCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::outputsPostCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit outputsPostSignal(output);
        emit outputsPostSignalFull(worker, output);
    } else {
        emit outputsPostSignalE(output, error_type, error_str);
        emit outputsPostSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::pendingTxs() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/pendingTxs");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::pendingTxsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::pendingTxsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<OAIInline_response_200_4> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        OAIInline_response_200_4 val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit pendingTxsSignal(output);
        emit pendingTxsSignalFull(worker, output);
    } else {
        emit pendingTxsSignalE(output, error_type, error_str);
        emit pendingTxsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::resendUnconfirmedTxns() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/resendUnconfirmedTxns");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::resendUnconfirmedTxnsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::resendUnconfirmedTxnsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit resendUnconfirmedTxnsSignal();
        emit resendUnconfirmedTxnsSignalFull(worker);
    } else {
        emit resendUnconfirmedTxnsSignalE(error_type, error_str);
        emit resendUnconfirmedTxnsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::richlist(const bool& include_distribution, const QString& n) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/richlist");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("include-distribution"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(include_distribution)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("n"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(n)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::richlistCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::richlistCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit richlistSignal(output);
        emit richlistSignalFull(worker, output);
    } else {
        emit richlistSignalE(output, error_type, error_str);
        emit richlistSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transaction(const QString& txid, const bool& encoded) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/transaction");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("txid"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(txid)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("encoded"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(encoded)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionSignal(output);
        emit transactionSignalFull(worker, output);
    } else {
        emit transactionSignalE(output, error_type, error_str);
        emit transactionSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transactionInject(const QString& rawtx) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/transaction/inject");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (rawtx != nullptr) {
        input.headers.insert("rawtx", "rawtx");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionInjectCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionInjectCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionInjectSignal(output);
        emit transactionInjectSignalFull(worker, output);
    } else {
        emit transactionInjectSignalE(output, error_type, error_str);
        emit transactionInjectSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transactionRaw(const QString& txid) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/transaction/raw");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("txid"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(txid)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionRawCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionRawCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionRawSignal(output);
        emit transactionRawSignalFull(worker, output);
    } else {
        emit transactionRawSignalE(output, error_type, error_str);
        emit transactionRawSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transactionVerify() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/transaction/verify");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionVerifyCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionVerifyCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionVerifySignal(output);
        emit transactionVerifySignalFull(worker, output);
    } else {
        emit transactionVerifySignalE(output, error_type, error_str);
        emit transactionVerifySignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transactionsGet(const QString& addrs, const QString& confirmed) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/transactions");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addrs"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addrs)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("confirmed"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(confirmed)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionsGetCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionsGetCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionsGetSignal(output);
        emit transactionsGetSignalFull(worker, output);
    } else {
        emit transactionsGetSignalE(output, error_type, error_str);
        emit transactionsGetSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::transactionsPost(const QString& addrs, const QString& confirmed) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/transactions");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addrs"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addrs)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("confirmed"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(confirmed)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::transactionsPostCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::transactionsPostCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit transactionsPostSignal(output);
        emit transactionsPostSignalFull(worker, output);
    } else {
        emit transactionsPostSignalE(output, error_type, error_str);
        emit transactionsPostSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::uxout(const QString& uxid) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/uxout");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("uxid"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(uxid)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::uxoutCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::uxoutCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit uxoutSignal(output);
        emit uxoutSignalFull(worker, output);
    } else {
        emit uxoutSignalE(output, error_type, error_str);
        emit uxoutSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::verifyAddress(const QString& address) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/address/verify");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("address"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(address)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::verifyAddressCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::verifyAddressCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIInline_response_200_7 output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit verifyAddressSignal(output);
        emit verifyAddressSignalFull(worker, output);
    } else {
        emit verifyAddressSignalE(output, error_type, error_str);
        emit verifyAddressSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::version() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/version");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::versionCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::versionCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit versionSignal();
        emit versionSignalFull(worker);
    } else {
        emit versionSignalE(error_type, error_str);
        emit versionSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::wallet(const QString& id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletSignal(output);
        emit walletSignalFull(worker, output);
    } else {
        emit walletSignalE(output, error_type, error_str);
        emit walletSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletBalance(const QString& id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/balance");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletBalanceCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletBalanceCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletBalanceSignal(output);
        emit walletBalanceSignalFull(worker, output);
    } else {
        emit walletBalanceSignalE(output, error_type, error_str);
        emit walletBalanceSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletCreate(const QString& seed, const QString& label, const qint32& scan, const bool& encrypt, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/create");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (seed != nullptr) {
        input.headers.insert("seed", "seed");
    }
    if (label != nullptr) {
        input.headers.insert("label", "label");
    }
    if (scan != nullptr) {
        input.headers.insert("scan", "scan");
    }
    if (encrypt != nullptr) {
        input.headers.insert("encrypt", "encrypt");
    }
    if (password != nullptr) {
        input.headers.insert("password", "password");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletCreateCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletCreateCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletCreateSignal(output);
        emit walletCreateSignalFull(worker, output);
    } else {
        emit walletCreateSignalE(output, error_type, error_str);
        emit walletCreateSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletDecrypt(const QString& id, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/decrypt");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (id != nullptr) {
        input.headers.insert("id", "id");
    }
    if (password != nullptr) {
        input.headers.insert("password", "password");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletDecryptCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletDecryptCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletDecryptSignal(output);
        emit walletDecryptSignalFull(worker, output);
    } else {
        emit walletDecryptSignalE(output, error_type, error_str);
        emit walletDecryptSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletEncrypt(const QString& id, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/encrypt");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (id != nullptr) {
        input.headers.insert("id", "id");
    }
    if (password != nullptr) {
        input.headers.insert("password", "password");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletEncryptCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletEncryptCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletEncryptSignal(output);
        emit walletEncryptSignalFull(worker, output);
    } else {
        emit walletEncryptSignalE(output, error_type, error_str);
        emit walletEncryptSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletFolder(const QString& addr) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallets/folderName");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("addr"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(addr)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletFolderCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletFolderCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIInline_response_200_6 output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletFolderSignal(output);
        emit walletFolderSignalFull(worker, output);
    } else {
        emit walletFolderSignalE(output, error_type, error_str);
        emit walletFolderSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletNewAddress(const QString& id, const QString& num, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/newAddress");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("num"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(num)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("password"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(password)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletNewAddressCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletNewAddressCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletNewAddressSignal(output);
        emit walletNewAddressSignalFull(worker, output);
    } else {
        emit walletNewAddressSignalE(output, error_type, error_str);
        emit walletNewAddressSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletNewSeed(const QString& entropy) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/newSeed");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("entropy"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(entropy)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletNewSeedCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletNewSeedCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletNewSeedSignal(output);
        emit walletNewSeedSignalFull(worker, output);
    } else {
        emit walletNewSeedSignalE(output, error_type, error_str);
        emit walletNewSeedSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletRecover(const QString& id, const QString& seed, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/wallet/recover");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (id != nullptr) {
        input.headers.insert("id", "id");
    }
    if (seed != nullptr) {
        input.headers.insert("seed", "seed");
    }
    if (password != nullptr) {
        input.headers.insert("password", "password");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletRecoverCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletRecoverCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletRecoverSignal(output);
        emit walletRecoverSignalFull(worker, output);
    } else {
        emit walletRecoverSignalE(output, error_type, error_str);
        emit walletRecoverSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletSeed(const QString& id, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/seed");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("password"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(password)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletSeedCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletSeedCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletSeedSignal(output);
        emit walletSeedSignalFull(worker, output);
    } else {
        emit walletSeedSignalE(output, error_type, error_str);
        emit walletSeedSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletSeedVerify(const QString& seed) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v2/wallet/seed/verify");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (seed != nullptr) {
        input.headers.insert("seed", "seed");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletSeedVerifyCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletSeedVerifyCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletSeedVerifySignal(output);
        emit walletSeedVerifySignalFull(worker, output);
    } else {
        emit walletSeedVerifySignalE(output, error_type, error_str);
        emit walletSeedVerifySignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletSpent(const QString& id, const QString& dst, const QString& coins, const QString& password) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/spend");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (id != nullptr) {
        input.headers.insert("id", "id");
    }
    if (dst != nullptr) {
        input.headers.insert("dst", "dst");
    }
    if (coins != nullptr) {
        input.headers.insert("coins", "coins");
    }
    if (password != nullptr) {
        input.headers.insert("password", "password");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletSpentCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletSpentCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletSpentSignal(output);
        emit walletSpentSignalFull(worker, output);
    } else {
        emit walletSpentSignalE(output, error_type, error_str);
        emit walletSpentSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletTransaction(const OAIInline_object& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/transaction");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    
    QString output = body.asJson();
    input.request_body.append(output);
    

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletTransactionCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletTransactionCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletTransactionSignal(output);
        emit walletTransactionSignalFull(worker, output);
    } else {
        emit walletTransactionSignalE(output, error_type, error_str);
        emit walletTransactionSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletTransactions(const QString& id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/transactions");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletTransactionsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletTransactionsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletTransactionsSignal(output);
        emit walletTransactionsSignalFull(worker, output);
    } else {
        emit walletTransactionsSignalE(output, error_type, error_str);
        emit walletTransactionsSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletUnload(const QString& id) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/unload");
    
    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("id"))
        .append("=")
        .append(QUrl::toPercentEncoding(::skyqt::toStringValue(id)));
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletUnloadCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletUnloadCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletUnloadSignal();
        emit walletUnloadSignalFull(worker);
    } else {
        emit walletUnloadSignalE(error_type, error_str);
        emit walletUnloadSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::walletUpdate(const QString& id, const QString& label) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallet/update");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "POST");

    if (id != nullptr) {
        input.headers.insert("id", "id");
    }
    if (label != nullptr) {
        input.headers.insert("label", "label");
    }

    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletUpdateCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletUpdateCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletUpdateSignal();
        emit walletUpdateSignalFull(worker);
    } else {
        emit walletUpdateSignalE(error_type, error_str);
        emit walletUpdateSignalEFull(worker, error_type, error_str);
    }
}

void
OAIDefaultApi::wallets() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/api/v1/wallets");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker();
    OAIHttpRequestInput input(fullPath, "GET");


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &OAIHttpRequestWorker::on_execution_finished,
            this,
            &OAIDefaultApi::walletsCallback);

    worker->execute(&input);
}

void
OAIDefaultApi::walletsCallback(OAIHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }
    QList<OAIInline_response_200_5> output;
    QString json(worker->response);
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    foreach(QJsonValue obj, jsonArray) {
        OAIInline_response_200_5 val;
        ::skyqt::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit walletsSignal(output);
        emit walletsSignalFull(worker, output);
    } else {
        emit walletsSignalE(output, error_type, error_str);
        emit walletsSignalEFull(worker, error_type, error_str);
    }
}


}
